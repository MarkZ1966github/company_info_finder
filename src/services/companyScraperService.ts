import axios from 'axios';\nimport * as cheerio from 'cheerio';\nimport { LRUCache } from 'lru-cache';\nimport { MOCK_COMPANY_DATA, AVAILABLE_COMPANIES } from './companyService';\n\n// Types\ntype DataSource = 'Wikipedia' | 'YahooFinance' | 'CompanyWebsite' | 'SECEDGAR' | 'NewsAPI' | 'MockData';\n\ninterface ScrapedData {\n  value: any;\n  timestamp: number;\n  source: DataSource;\n}\n\ninterface CompanyData {\n  name: string;\n  ticker: string;\n  founded: string;\n  headquarters: string;\n  industry: string;\n  employees: string;\n  website: string;\n  description: string;\n  leadership: Array<{ name: string; position: string; since: string }>;\n  financials: {\n    revenue: number[];\n    profit: number[];\n    years: string[];\n    metrics: {\n      peRatio: number;\n      marketCap: string;\n      dividendYield: string;\n      debtToEquity: number;\n    }\n  };\n  risk: {\n    overall: string;\n    factors: Array<{ name: string; score: number }>;\n    successProbability: number;\n  };\n  dataSources?: Record<string, DataSource>;\n}\n\n// Cache configuration - 24 hour TTL\nconst cache = new LRUCache<string, ScrapedData>({\n  max: 500, // Store up to 500 items\n  ttl: 1000 * 60 * 60 * 24, // 24 hour TTL\n});\n\n// Rate limiting configuration\nconst rateLimits: Record<string, { lastRequest: number; count: number }> = {};\nconst RATE_LIMIT_WINDOW = 60 * 60 * 1000; // 1 hour in milliseconds\nconst MAX_REQUESTS_PER_DOMAIN = 100; // Max 100 requests per hour per domain\nconst MIN_REQUEST_INTERVAL = 2000; // Min 2 seconds between requests to same domain\n\n// User agent for requests\nconst USER_AGENT = 'Company Research Dashboard/1.0 (research-purposes; respectful-bot)';\n\n// Helper function to enforce rate limiting\nconst checkRateLimit = (domain: string): boolean => {\n  const now = Date.now();\n  if (!rateLimits[domain]) {\n    rateLimits[domain] = { lastRequest: 0, count: 0 };\n  }\n  \n  // Reset count if window has passed\n  if (now - rateLimits[domain].lastRequest > RATE_LIMIT_WINDOW) {\n    rateLimits[domain].count = 0;\n  }\n  \n  // Check if we've exceeded the max requests\n  if (rateLimits[domain].count >= MAX_REQUESTS_PER_DOMAIN) {\n    return false;\n  }\n  \n  // Check if we need to wait between requests\n  if (now - rateLimits[domain].lastRequest < MIN_REQUEST_INTERVAL) {\n    return false;\n  }\n  \n  return true;\n};\n\n// Helper function to update rate limit counters\nconst updateRateLimit = (domain: string): void => {\n  if (!rateLimits[domain]) {\n    rateLimits[domain] = { lastRequest: 0, count: 0 };\n  }\n  \n  rateLimits[domain].lastRequest = Date.now();\n  rateLimits[domain].count += 1;\n};\n\n// Helper function to extract domain from URL\nconst extractDomain = (url: string): string => {\n  try {\n    const hostname = new URL(url).hostname;\n    return hostname;\n  } catch (error) {\n    return url;\n  }\n};\n\n// Helper function to make rate-limited requests\nconst makeRequest = async (url: string, retries = 3): Promise<{ data: string; source: string }> => {\n  const domain = extractDomain(url);\n  \n  // Check rate limit\n  if (!checkRateLimit(domain)) {\n    // If we can't make the request now, wait and retry\n    if (retries > 0) {\n      const backoffTime = Math.pow(2, 4 - retries) * 1000; // Exponential backoff\n      await new Promise(resolve => setTimeout(resolve, backoffTime));\n      return makeRequest(url, retries - 1);\n    } else {\n      throw new Error(`Rate limit exceeded for ${domain}`);\n    }\n  }\n  \n  try {\n    // Update rate limit counter before making request\n    updateRateLimit(domain);\n    \n    // Make the request with appropriate headers\n    const response = await axios.get(url, {\n      headers: {\n        'User-Agent': USER_AGENT,\n        'Accept': 'text/html,application/xhtml+xml,application/xml',\n        'Accept-Language': 'en-US,en;q=0.9',\n      },\n      timeout: 10000, // 10 second timeout\n    });\n    \n    return { data: response.data, source: domain };\n  } catch (error: any) {\n    // Handle specific errors\n    if (error.response && error.response.status === 429) {\n      // Rate limited - get retry-after header if available\n      const retryAfter = error.response.headers['retry-after'] \n        ? parseInt(error.response.headers['retry-after']) * 1000 \n        : 5000;\n      \n      if (retries > 0) {\n        await new Promise(resolve => setTimeout(resolve, retryAfter));\n        return makeRequest(url, retries - 1);\n      }\n    }\n    \n    // For other errors, retry with backoff if we have retries left\n    if (retries > 0) {\n      const backoffTime = Math.pow(2, 4 - retries) * 1000;\n      await new Promise(resolve => setTimeout(resolve, backoffTime));\n      return makeRequest(url, retries - 1);\n    }\n    \n    throw error;\n  }\n};\n\n// Function to search Wikipedia for company data\nconst searchWikipedia = async (companyName: string): Promise<Partial<CompanyData>> => {\n  const cacheKey = `wikipedia:${companyName}`;\n  const cachedData = cache.get(cacheKey);\n  \n  if (cachedData) {\n    return cachedData.value;\n  }\n  \n  try {\n    const searchUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(companyName.replace(/ /g, '_'))}`;\n    const { data, source } = await makeRequest(searchUrl);\n    const $ = cheerio.load(data);\n    \n    // Extract basic info from infobox\n    const result: Partial<CompanyData> = {\n      name: companyName,\n      dataSources: { name: 'Wikipedia' }\n    };\n    \n    // Get founded date\n    const foundedLabel = $('.infobox-label:contains(\"Founded\"), .infobox-label:contains(\"foundation\"), .infobox-label:contains(\"Formation\")');\n    if (foundedLabel.length) {\n      const founded = foundedLabel.next('.infobox-data').text().trim();\n      result.founded = founded;\n      result.dataSources = { ...result.dataSources, founded: 'Wikipedia' };\n    }\n    \n    // Get headquarters\n    const hqLabel = $('.infobox-label:contains(\"Headquarters\"), .infobox-label:contains(\"Location\")');\n    if (hqLabel.length) {\n      const headquarters = hqLabel.next('.infobox-data').text().trim();\n      result.headquarters = headquarters;\n      result.dataSources = { ...result.dataSources, headquarters: 'Wikipedia' };\n    }\n    \n    // Get industry\n    const industryLabel = $('.infobox-label:contains(\"Industry\")');\n    if (industryLabel.length) {\n      const industry = industryLabel.next('.infobox-data').text().trim();\n      result.industry = industry;\n      result.dataSources = { ...result.dataSources, industry: 'Wikipedia' };\n    }\n    \n    // Get description from first paragraph\n    const firstParagraph = $('#mw-content-text p').not('.mw-empty-elt').first().text().trim();\n    if (firstParagraph) {\n      result.description = firstParagraph;\n      result.dataSources = { ...result.dataSources, description: 'Wikipedia' };\n    }\n    \n    // Get website\n    const websiteLabel = $('.infobox-label:contains(\"Website\")');\n    if (websiteLabel.length) {\n      const website = websiteLabel.next('.infobox-data').find('a').attr('href');\n      if (website) {\n        result.website = website.replace(/^https?:\\/\\//, '');\n        result.dataSources = { ...result.dataSources, website: 'Wikipedia' };\n      }\n    }\n    \n    // Get employees count\n    const employeesLabel = $('.infobox-label:contains(\"Employees\")');\n    if (employeesLabel.length) {\n      const employees = employeesLabel.next('.infobox-data').text().trim();\n      result.employees = employees;\n      result.dataSources = { ...result.dataSources, employees: 'Wikipedia' };\n    }\n    \n    // Store in cache\n    cache.set(cacheKey, {\n      value: result,\n      timestamp: Date.now(),\n      source: 'Wikipedia'\n    });\n    \n    return result;\n  } catch (error) {\n    console.error(`Error scraping Wikipedia for ${companyName}:`, error);\n    return {};\n  }\n};\n\n// Function to search Yahoo Finance for company data\nconst searchYahooFinance = async (companyName: string, ticker?: string): Promise<Partial<CompanyData>> => {\n  // Try to find ticker if not provided\n  let stockTicker = ticker;\n  if (!stockTicker) {\n    // Use ticker from mock data if available\n    const mockCompany = Object.values(MOCK_COMPANY_DATA).find(c => \n      c.name.toLowerCase() === companyName.toLowerCase());\n    if (mockCompany) {\n      stockTicker = mockCompany.ticker;\n    }\n  }\n  \n  // Can't proceed without ticker\n  if (!stockTicker) {\n    return {};\n  }\n  \n  const cacheKey = `yahoo:${stockTicker}`;\n  const cachedData = cache.get(cacheKey);\n  \n  if (cachedData) {\n    return cachedData.value;\n  }\n  \n  try {\n    const url = `https://finance.yahoo.com/quote/${encodeURIComponent(stockTicker)}`;\n    const { data, source } = await makeRequest(url);\n    const $ = cheerio.load(data);\n    \n    const result: Partial<CompanyData> = {\n      ticker: stockTicker,\n      dataSources: { ticker: 'YahooFinance' }\n    };\n    \n    // Extract financial metrics\n    const marketCap = $('[data-test=\"MARKET_CAP-value\"]').text().trim();\n    const peRatio = $('[data-test=\"PE_RATIO-value\"]').text().trim();\n    const dividendYield = $('[data-test=\"DIVIDEND_AND_YIELD-value\"]').text().split(' ').pop()?.trim() || '0%';\n    \n    result.financials = {\n      revenue: [],\n      profit: [],\n      years: ['2019', '2020', '2021', '2022', '2023'],\n      metrics: {\n        marketCap: marketCap || 'Unknown',\n        peRatio: parseFloat(peRatio) || 0,\n        dividendYield: dividendYield,\n        debtToEquity: 0 // Need to find this on another page\n      }\n    };\n    \n    result.dataSources = { \n      ...result.dataSources, \n      'financials.metrics.marketCap': 'YahooFinance',\n      'financials.metrics.peRatio': 'YahooFinance',\n      'financials.metrics.dividendYield': 'YahooFinance'\n    };\n    \n    // Store in cache\n    cache.set(cacheKey, {\n      value: result,\n      timestamp: Date.now(),\n      source: 'YahooFinance'\n    });\n    \n    return result;\n  } catch (error) {\n    console.error(`Error scraping Yahoo Finance for ${companyName}:`, error);\n    return {};\n  }\n};\n\n// Function to estimate risk based on available data\nconst estimateRisk = (companyData: Partial<CompanyData>): Partial<CompanyData> => {\n  // This is a simplified risk assessment algorithm\n  // In a real implementation, this would use more sophisticated analysis\n  \n  const factors: Array<{ name: string; score: number }> = [];\n  let overallRiskScore = 0;\n  let factorCount = 0;\n  \n  // Industry-based risk factors\n  if (companyData.industry) {\n    const industry = companyData.industry.toLowerCase();\n    \n    // Tech companies often face innovation pressure\n    if (industry.includes('tech') || industry.includes('software') || industry.includes('computing')) {\n      factors.push({ name: 'Innovation Pace', score: 3 });\n      factors.push({ name: 'Market Competition', score: 4 });\n      overallRiskScore += 7;\n      factorCount += 2;\n    }\n    \n    // Financial companies face regulatory and economic risks\n    if (industry.includes('financ') || industry.includes('bank') || industry.includes('insurance')) {\n      factors.push({ name: 'Regulatory Changes', score: 4 });\n      factors.push({ name: 'Economic Downturn', score: 5 });\n      overallRiskScore += 9;\n      factorCount += 2;\n    }\n    \n    // Retail companies face supply chain and competition risks\n    if (industry.includes('retail') || industry.includes('commerce')) {\n      factors.push({ name: 'Supply Chain Disruption', score: 4 });\n      factors.push({ name: 'Market Competition', score: 4 });\n      overallRiskScore += 8;\n      factorCount += 2;\n    }\n    \n    // Healthcare companies face regulatory and litigation risks\n    if (industry.includes('health') || industry.includes('pharma') || industry.includes('medical')) {\n      factors.push({ name: 'Regulatory Changes', score: 4 });\n      factors.push({ name: 'Litigation Risk', score: 4 });\n      factors.push({ name: 'R&D Success Rate', score: 3 });\n      overallRiskScore += 11;\n      factorCount += 3;\n    }\n  }\n  \n  // If we couldn't determine industry-specific factors, add generic ones\n  if (factors.length === 0) {\n    factors.push({ name: 'Market Competition', score: 3 });\n    factors.push({ name: 'Economic Conditions', score: 3 });\n    factors.push({ name: 'Regulatory Environment', score: 3 });\n    overallRiskScore = 9;\n    factorCount = 3;\n  }\n  \n  // Financial metrics-based risk assessment\n  if (companyData.financials?.metrics) {\n    const { peRatio, debtToEquity } = companyData.financials.metrics;\n    \n    // High P/E ratio might indicate overvaluation\n    if (peRatio > 30) {\n      factors.push({ name: 'Valuation Risk', score: 4 });\n      overallRiskScore += 4;\n      factorCount += 1;\n    }\n    \n    // High debt-to-equity ratio indicates financial risk\n    if (debtToEquity > 2) {\n      factors.push({ name: 'Debt Level', score: 4 });\n      overallRiskScore += 4;\n      factorCount += 1;\n    }\n  }\n  \n  // Calculate average risk score\n  const avgRiskScore = factorCount > 0 ? overallRiskScore / factorCount : 3;\n  \n  // Determine overall risk category\n  let overall = 'Moderate';\n  let successProbability = 0.5;\n  \n  if (avgRiskScore < 2) {\n    overall = 'Very Low';\n    successProbability = 0.9;\n  } else if (avgRiskScore < 3) {\n    overall = 'Low';\n    successProbability = 0.75;\n  } else if (avgRiskScore < 4) {\n    overall = 'Moderate';\n    successProbability = 0.5;\n  } else if (avgRiskScore < 4.5) {\n    overall = 'High';\n    successProbability = 0.3;\n  } else {\n    overall = 'Very High';\n    successProbability = 0.1;\n  }\n  \n  return {\n    risk: {\n      overall,\n      factors,\n      successProbability\n    },\n    dataSources: { risk: 'Algorithmic Estimate' }\n  };\n};\n\n// Function to search for companies by name using web search\nexport const searchCompanies = async (query: string): Promise<string[]> => {\n  if (!query.trim()) return [];\n  \n  const cacheKey = `search:${query.toLowerCase()}`;\n  const cachedResults = cache.get(cacheKey);\n  \n  if (cachedResults) {\n    return cachedResults.value;\n  }\n  \n  try {\n    // First try to find matches in our mock data\n    const normalizedQuery = query.toLowerCase().trim();\n    const mockMatches = AVAILABLE_COMPANIES.filter(company => \n      company.toLowerCase().includes(normalizedQuery)\n    );\n    \n    if (mockMatches.length > 0) {\n      // Cache the results\n      cache.set(cacheKey, {\n        value: mockMatches,\n        timestamp: Date.now(),\n        source: 'MockData'\n      });\n      \n      return mockMatches;\n    }\n    \n    // If no matches in mock data, we could implement a real web search here\n    // For now, we'll return an empty array\n    return [];\n  } catch (error) {\n    console.error('Error searching for companies:', error);\n    return [];\n  }\n};\n\n// Function to get detailed company data\nexport const getCompanyData = async (companyName: string): Promise<CompanyData> => {\n  const cacheKey = `company:${companyName.toLowerCase()}`;\n  const cachedData = cache.get(cacheKey);\n  \n  if (cachedData) {\n    return cachedData.value;\n  }\n  \n  try {\n    // First check if we have this company in our mock data\n    const mockCompany = Object.entries(MOCK_COMPANY_DATA).find(([name]) => \n      name.toLowerCase() === companyName.toLowerCase() ||\n      name.toLowerCase().includes(companyName.toLowerCase())\n    );\n    \n    let baseData: Partial<CompanyData> = {};\n    let dataSources: Record<string, DataSource> = {};\n    \n    if (mockCompany) {\n      // Use mock data as base\n      baseData = { ...mockCompany[1] };\n      dataSources = Object.keys(baseData).reduce((acc, key) => {\n        acc[key] = 'MockData';\n        return acc;\n      }, {} as Record<string, DataSource>);\n    } else {\n      // Create a skeleton structure\n      baseData = {\n        name: companyName,\n        ticker: '',\n        founded: '',\n        headquarters: '',\n        industry: '',\n        employees: '',\n        website: '',\n        description: '',\n        leadership: [],\n        financials: {\n          revenue: [0, 0, 0, 0, 0],\n          profit: [0, 0, 0, 0, 0],\n          years: ['2019', '2020', '2021', '2022', '2023'],\n          metrics: {\n            peRatio: 0,\n            marketCap: '',\n            dividendYield: '',\n            debtToEquity: 0\n          }\n        },\n        risk: {\n          overall: 'Unknown',\n          factors: [],\n          successProbability: 0.5\n        }\n      };\n    }\n    \n    // Try to scrape additional data from Wikipedia\n    const wikipediaData = await searchWikipedia(companyName);\n    \n    // Merge Wikipedia data\n    baseData = {\n      ...baseData,\n      ...wikipediaData,\n      dataSources: {\n        ...dataSources,\n        ...wikipediaData.dataSources\n      }\n    };\n    \n    // Try to scrape financial data from Yahoo Finance\n    const yahooData = await searchYahooFinance(companyName, baseData.ticker);\n    \n    // Merge Yahoo Finance data\n    if (yahooData.financials?.metrics) {\n      baseData = {\n        ...baseData,\n        ticker: yahooData.ticker || baseData.ticker,\n        financials: {\n          ...baseData.financials,\n          metrics: {\n            ...baseData.financials?.metrics,\n            ...yahooData.financials.metrics\n          }\n        },\n        dataSources: {\n          ...baseData.dataSources,\n          ...yahooData.dataSources\n        }\n      };\n    }\n    \n    // Estimate risk if we don't have it from mock data\n    if (baseData.dataSources?.risk === 'MockData') {\n      // We already have risk data from mock data, no need to estimate\n    } else {\n      const riskData = estimateRisk(baseData);\n      baseData = {\n        ...baseData,\n        risk: riskData.risk || baseData.risk,\n        dataSources: {\n          ...baseData.dataSources,\n          ...riskData.dataSources\n        }\n      };\n    }\n    \n    // Cache the combined data\n    const finalData = baseData as CompanyData;\n    cache.set(cacheKey, {\n      value: finalData,\n      timestamp: Date.now(),\n      source: 'Combined'\n    });\n    \n    return finalData;\n  } catch (error) {\n    console.error('Error fetching company data:', error);\n    \n    // Fallback to mock data or generic data\n    const matchedCompany = Object.entries(MOCK_COMPANY_DATA).find(([name]) => \n      name.toLowerCase() === companyName.toLowerCase() ||\n      name.toLowerCase().includes(companyName.toLowerCase())\n    );\n    \n    if (matchedCompany) {\n      return {\n        ...matchedCompany[1],\n        dataSources: { _all: 'MockData (Fallback)' }\n      };\n    }\n    \n    // Return generic data\n    return {\n      name: companyName,\n      ticker: 'UNKNOWN',\n      founded: 'Unknown',\n      headquarters: 'Unknown',\n      industry: 'Unknown',\n      employees: 'Unknown',\n      website: '',\n      description: `Information for ${companyName} is currently being compiled.`,\n      leadership: [],\n      financials: {\n        revenue: [0, 0, 0, 0, 0],\n        profit: [0, 0, 0, 0, 0],\n        years: ['2019', '2020', '2021', '2022', '2023'],\n        metrics: {\n          peRatio: 0,\n          marketCap: 'Unknown',\n          dividendYield: 'Unknown',\n          debtToEquity: 0\n        }\n      },\n      risk: {\n        overall: 'Unknown',\n        factors: [],\n        successProbability: 0.5\n      },\n      dataSources: { _all: 'Error Fallback' }\n    };\n  }\n};\n